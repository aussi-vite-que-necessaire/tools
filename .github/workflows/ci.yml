name: CI & Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # --- JOB 1: LINT & TYPECHECK (Fast, no browser needed) ---
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run type check
        run: npm run typecheck

  # --- JOB 2: UNIT TESTS (Fast, mocked browser) ---
  unit-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit

  # --- JOB 3: E2E TESTS (Slower, needs browser) ---
  e2e-test:
    runs-on: ubuntu-latest
    # Use the base image which already has Chromium installed
    container:
      image: ghcr.io/aussi-vite-que-necessaire/tools/tools-api-base:latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Node is already in the container, but we need to ensure permissions/cache
      # We skip setup-node because the container has node, but we might want caching.
      # actions/setup-node might not work perfectly inside a container if node is already there.
      # Let's just run npm ci directly.
      
      - name: Install dependencies
        run: npm ci

      - name: Run E2E tests
        run: npm run test:e2e
        env:
          # Ensure Puppeteer uses the system chromium from the base image
          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true
          PUPPETEER_EXECUTABLE_PATH: /usr/bin/chromium

  # --- JOB 4 : BUILD & PUSH DOCKER IMAGE (only on push to main) ---
  build-and-push:
    needs: [check, unit-test, e2e-test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Lowercase Repo Name
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ghcr.io/${{ env.REPO_LOWER }}/tools-api:latest
          cache-from: type=gha,scope=tools-api
          cache-to: type=gha,mode=max,scope=tools-api

  # --- JOB 5 : D√âPLOIEMENT SUR VPS (only on push to main) ---
  deploy:
    needs: [build-and-push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Lowercase Repo Name
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

      # --- NETTOYAGE ---
      - name: Force Clean Remote Directory
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            mkdir -p apps/${{ vars.PROJECT_NAME }}
            cd apps/${{ vars.PROJECT_NAME }}
            rm -rf docker-compose.yml .env || true

      # --- ENVOI DU DOCKER-COMPOSE ---
      - name: Copy docker-compose.yml to VPS
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "docker-compose.yml"
          target: "apps/${{ vars.PROJECT_NAME }}"

      # --- D√âPLOIEMENT ---
      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1
        env:
          REPO_LOWER: ${{ env.REPO_LOWER }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: REPO_LOWER
          script: |
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker image prune -f

            cd ~/apps/${{ vars.PROJECT_NAME }}

            # --- A. G√âN√âRATION DU .ENV ---
            echo "üîß G√©n√©ration .env..."
            REPO_LOWER="$REPO_LOWER"
            # Use API_URL if set, otherwise use MAIN_DOMAIN directly
            if [ -n "${{ vars.API_URL }}" ]; then
              DOMAIN_NAME="${{ vars.API_URL }}"
            else
              DOMAIN_NAME="https://${{ vars.MAIN_DOMAIN }}"
            fi
            # Remove https:// if present for Traefik Host rule
            DOMAIN_NAME_CLEAN=$(echo "$DOMAIN_NAME" | sed 's|https\?://||')
            cat <<EOF > .env
            IMAGE_NAME=ghcr.io/$REPO_LOWER/tools-api:latest
            PROJECT_NAME=${{ vars.PROJECT_NAME }}
            NODE_ENV=production
            PORT=3000
            API_URL=$DOMAIN_NAME
            DOMAIN_NAME=$DOMAIN_NAME_CLEAN
            PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
            PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium
            EOF
            chmod 600 .env

            # --- B. PULL & START ---
            echo "üì• Pull & Start..."
            docker compose pull
            # Force recreation to apply new Traefik labels
            docker compose up -d --force-recreate --remove-orphans

            # --- C. HEALTH CHECK ---
            echo "üè• V√©rification de la sant√© du service..."
            sleep 10
            MAX_WAIT=60
            WAITED=0
            SERVICE_NAME="tools-api"
            while [ $WAITED -lt $MAX_WAIT ]; do
              if docker compose exec -T $SERVICE_NAME node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
                echo "‚úÖ Service healthy !"
                break
              fi
              echo "‚è≥ Attente... ($WAITED/$MAX_WAIT secondes)"
              sleep 5
              WAITED=$((WAITED + 5))
            done

            if [ $WAITED -ge $MAX_WAIT ]; then
              echo "‚ö†Ô∏è Service health check timeout, mais le d√©ploiement continue"
              docker compose logs --tail=50 $SERVICE_NAME
            fi

            echo "‚úÖ D√©ploiement termin√© !"
